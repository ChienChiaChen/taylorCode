package test.taylor.com.taylorcode.kotlin.coroutine.mvi

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import test.taylor.com.taylorcode.kotlin.coroutine.mvvm.*
import javax.net.ssl.SSLHandshakeException

class NewsViewModel(private val newsRepo: NewsRepo) : ViewModel() {
    private val _feedsIntent = MutableSharedFlow<FeedsIntent>()

    val newsState =
        _feedsIntent
            .toNewsStateFlow()
            .flowOn(Dispatchers.IO)
            .shareIn(viewModelScope, SharingStarted.Eagerly)

    val _userInfoStateFlow = MutableStateFlow(UserInfoModel(loading = true))
    val userInfoStateFlow: StateFlow<UserInfoModel> = _userInfoStateFlow


    val newState2 =
        _feedsIntent
            .onEach { Log.v("ttaylor","showNews() feedsIntent intent=$it") }
            .toPartialChangeFlow()
            .scan(NewsState.initial) { oldState, partialChange -> partialChange.reduce(oldState) }
            .onEach { Log.v("ttaylor","showNews() onEach() newState=$it") }
            .flowOn(Dispatchers.IO)
            .stateIn(viewModelScope, SharingStarted.Eagerly,NewsState.initial)

    fun send(intent: FeedsIntent) {
        viewModelScope.launch { _feedsIntent.emit(intent) }
    }

    /**
     * case: use StateFlow like LiveData
     */
    fun fetchUserInfo() {
        viewModelScope.launch {
            delay(2000)
            val userInfo = userInfoStateFlow.value.copy(userName = "taylor", loading = false)
            _userInfoStateFlow.emit(userInfo)
        }
    }

    /**
     * case: process flow generated by repo, and convert repo data to ui model
     */
    val userInfoSharedFlow =
        flowOf(newsRepo.localUserInfoFlow, newsRepo.remoteUserInfoFlow)
            .flattenMerge()
            .map { UserInfoModel(userName = it.name, loading = false) }
            .onStart { emit(UserInfoModel(userName = "", loading = true)) }
            .shareIn(viewModelScope, SharingStarted.WhileSubscribed())

    val newsFlow =
        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow("1", "8"))
            .flattenMerge()
            .transformWhile {
                emit(it.news)
                !it.abort
            }
            .map { NewsState(it, false, isLoadingMore = false, errorMessage = "") }
            .flowOn(Dispatchers.IO) // case: change the upstream thread
            .onStart { emit(NewsState(emptyList(), true, false, "")) }
            .catch {
                if (it is SSLHandshakeException)
                    emit(
                        NewsState(
                            emptyList(),
                            false,
                            isLoadingMore = false,
                            errorMessage = "network error,show old news"
                        )
                    )
            }
            .shareIn(viewModelScope, SharingStarted.Lazily)

    /**
     * case: multiple flow in serial
     */
    val newsSerialFlow =
        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow("1", "8"))
            .flattenConcat()
            .map { NewsState(it.news, false, isLoadingMore = false, errorMessage = "") }
            .flowOn(Dispatchers.IO) // case: change the upstream thread
            .onStart {
                emit(
                    NewsState(
                        emptyList(),
                        true,
                        isLoadingMore = false,
                        errorMessage = ""
                    )
                )
            }
            .shareIn(viewModelScope, SharingStarted.Lazily)

    private fun Flow<FeedsIntent>.toPartialChangeFlow(): Flow<FeedsPartialChange> = merge(
        filterIsInstance<FeedsIntent.Init>().flatMapConcat { it.toPartialChangeFlow() },
        filterIsInstance<FeedsIntent.More>().flatMapConcat { it.toPartialChangeFlow() },
        filterIsInstance<FeedsIntent.Report>().flatMapConcat { it.toPartialChangeFlow() },
    )

    private fun FeedsIntent.More.toPartialChangeFlow() =
        newsRepo.remoteNewsFlow("", "10")
            .map { if (it.news.isEmpty()) More.Fail("no more news") else More.Success(it.news) }
            .onStart { emit(More.Loading) }
            .catch { emit(More.Fail("load more failed by xxx")) }


    private fun FeedsIntent.Init.toPartialChangeFlow() =
        flowOf(
            newsRepo.localNewsOneShotFlow,
            newsRepo.remoteNewsFlow(this.type.toString(), this.count.toString())
        )
            .flattenMerge()
            .transformWhile {
                emit(it.news)
                !it.abort
            }
            .map { news -> if (news.isEmpty()) Init.Fail("no more news") else Init.Success(news) }
            .onStart { emit(Init.Loading) }
            .catch {
                if (it is SSLHandshakeException)
                    emit(Init.Fail("network error,show old news"))
            }

    private fun FeedsIntent.Report.toPartialChangeFlow() =
        newsRepo.reportNews(id)
            .map { if(it >= 0L) Report.Success(it) else Report.Fail}
            .catch { emit((Report.Fail)) }

    /**
     * case: turn Intent flow to state flow
     */
    private fun Flow<FeedsIntent>.toNewsStateFlow(): Flow<NewsState> = merge(
        filterIsInstance<FeedsIntent.Init>()
            .flatMapConcat { it.toFetchInitPageFlow() },
        filterIsInstance<FeedsIntent.Report>()
            .flatMapConcat { flow { } },
        filterIsInstance<FeedsIntent.More>()
            .flatMapConcat {
                flow { emit(newsRepo.getLocalNewsBean()) }
                    .map {
                        NewsState(it.result ?: emptyList(), false, false, "")
                    }
            }
    )

    /**
     * case: turn Intent to network fetching flow
     */
    private fun FeedsIntent.Init.toFetchInitPageFlow() =
        flowOf(
            newsRepo.localNewsOneShotFlow,
            newsRepo.remoteNewsFlow(this.type.toString(), this.count.toString())
        )
            .flattenMerge()
            .transformWhile {
                emit(it.news)
                !it.abort
            }
            .map { NewsState(it, false, false, "") }
            .catch {
                if (it is SSLHandshakeException)
                    emit(
                        NewsState(
                            emptyList(),
                            isLoading = false,
                            isLoadingMore = false,
                            errorMessage = "network error,show old news"
                        )
                    )
            }
}

/**
 * case: inject repo instance which need context as an input param
 */
class NewsViewModelFactory(private val newsRepo: NewsRepo) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return NewsViewModel(newsRepo) as T
    }
}

package test.taylor.com.taylorcode.kotlin.coroutine.mvvm

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.net.ssl.SSLHandshakeException

class NewsViewModel(private val newsRepo: NewsRepo) : ViewModel() {
    private val _userInfoStateFlow = MutableStateFlow(UserInfoModel(loading = true))
    val userInfoStateFlow: StateFlow<UserInfoModel> = _userInfoStateFlow

    /**
     * case: use StateFlow like LiveData
     */
    fun fetchUserInfo() {
        viewModelScope.launch {
            delay(2000)
            val userInfo = userInfoStateFlow.value.copy(userName = "taylor", loading = false)
            _userInfoStateFlow.emit(userInfo)
        }
    }

    /**
     * case: process flow generated by repo, and convert repo data to ui model
     */
    val userInfoSharedFlow =
        flowOf(newsRepo.localUserInfoFlow, newsRepo.remoteUserInfoFlow)
            .flattenMerge()
            .map { UserInfoModel(userName = it.name, loading = false) }
            .onStart { emit(UserInfoModel(userName = "", loading = true)) }
            .shareIn(viewModelScope, SharingStarted.WhileSubscribed())

    val newsFlow =
        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow)
            .flattenMerge()
            .transformWhile {
                emit(it.news)
                !it.abort
            }
            .map { NewsModel(it, false) }
            .flowOn(Dispatchers.IO) // case: change the upstream thread
            .onStart { emit(NewsModel(emptyList(), true)) }
            .catch {
                if (it is SSLHandshakeException)
                    emit(
                        NewsModel(
                            emptyList(),
                            false,
                            "network error,show old news"
                        )
                    )
            }
            .stateIn(viewModelScope, SharingStarted.Lazily,NewsModel(emptyList(), true))
            .shareIn(viewModelScope, SharingStarted.Lazily)

    val newsSerialFlow =
        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow)
            .flattenConcat()
            .map { NewsModel(it.news, false) }
            .flowOn(Dispatchers.IO) // case: change the upstream thread
            .onStart { emit(NewsModel(emptyList(), true)) }
            .shareIn(viewModelScope, SharingStarted.Lazily)
}

/**
 * case: inject repo instance which need context as an input param
 */
class NewsViewModelFactory(private val newsRepo: NewsRepo) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return NewsViewModel(newsRepo) as T
    }
}
package test.taylor.com.taylorcode.kotlin.coroutine.mvvm

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.net.ssl.SSLHandshakeException

class NewsViewModel(private val newsRepo: NewsRepo) : ViewModel() {
    private val _feedsIntent = MutableSharedFlow<FeedsIntent>()

    val newsState =
        _feedsIntent
            .toNewsStateFlow()
            .flowOn(Dispatchers.IO)
            .shareIn(viewModelScope, SharingStarted.Eagerly)

    val _userInfoStateFlow = MutableStateFlow(UserInfoModel(loading = true))
    val userInfoStateFlow: StateFlow<UserInfoModel> = _userInfoStateFlow


    fun send(intent: FeedsIntent) {
        viewModelScope.launch { _feedsIntent.emit(intent) }
    }

    /**
     * case: use StateFlow like LiveData
     */
    fun fetchUserInfo() {
        viewModelScope.launch {
            delay(2000)
            val userInfo = userInfoStateFlow.value.copy(userName = "taylor", loading = false)
            _userInfoStateFlow.emit(userInfo)
        }
    }

    /**
     * case: process flow generated by repo, and convert repo data to ui model
     */
    val userInfoSharedFlow =
        flowOf(newsRepo.localUserInfoFlow, newsRepo.remoteUserInfoFlow)
            .flattenMerge()
            .map { UserInfoModel(userName = it.name, loading = false) }
            .onStart { emit(UserInfoModel(userName = "", loading = true)) }
            .shareIn(viewModelScope, SharingStarted.WhileSubscribed())

    val newsFlow =
        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow("1", "8"))
            .flattenMerge()
            .transformWhile {
                emit(it.news)
                !it.abort
            }
            .map { NewsState(it, false) }
            .flowOn(Dispatchers.IO) // case: change the upstream thread
            .onStart { emit(NewsState(emptyList(), true)) }
            .catch {
                if (it is SSLHandshakeException)
                    emit(
                        NewsState(
                            emptyList(),
                            false,
                            "network error,show old news"
                        )
                    )
            }
            .shareIn(viewModelScope, SharingStarted.Lazily)

    /**
     * case: multiple flow in serial
     */
    val newsSerialFlow =
        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow("1", "8"))
            .flattenConcat()
            .map { NewsState(it.news, false) }
            .flowOn(Dispatchers.IO) // case: change the upstream thread
            .onStart { emit(NewsState(emptyList(), true)) }
            .shareIn(viewModelScope, SharingStarted.Lazily)

    /**
     * case: turn Intent flow to state flow
     */
    private fun Flow<FeedsIntent>.toNewsStateFlow(): Flow<NewsState> = merge(
        filterIsInstance<FeedsIntent.InitIntent>()
            .flatMapConcat { it.toFetchInitPageFlow() },
        filterIsInstance<FeedsIntent.RemoveIntent>()
            .flatMapConcat { flow { } },
        filterIsInstance<FeedsIntent.MorePageIntent>()
            .flatMapConcat { flow { } }
    )

    /**
     * case: turn Intent to network fetching flow
     */
    private fun FeedsIntent.InitIntent.toFetchInitPageFlow() =
        flowOf(
            newsRepo.localNewsOneShotFlow,
            newsRepo.remoteNewsFlow(this.type.toString(), this.count.toString())
        )
            .flattenMerge()
            .transformWhile {
                emit(it.news)
                !it.abort
            }
            .map { NewsState(it, false) }
            .onStart { emit(NewsState(emptyList(), true)) }
            .catch {
                if (it is SSLHandshakeException)
                    emit(
                        NewsState(
                            emptyList(),
                            false,
                            "network error,show old news"
                        )
                    )
            }
}

/**
 * case: inject repo instance which need context as an input param
 */
class NewsViewModelFactory(private val newsRepo: NewsRepo) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return NewsViewModel(newsRepo) as T
    }
}


sealed class FeedsIntent {
    data class InitIntent(val type: Int, val count: Int) : FeedsIntent()
    data class MorePageIntent(val timestamp: Long, val count: Int) : FeedsIntent()
    data class RemoveIntent(val id: Long) : FeedsIntent()
}